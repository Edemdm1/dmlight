'use strict';

(function () {
  // Polyfill для методів remove() для старих версій браузерів
  var removePolyfill = function () {
    var types = ["DocumentType", "Element", "CharacterData"];

    // Функція видалення елементів
    var removeNode = function () {
      if (this.parentNode !== null) {
        this.parentNode.removeChild(this);
      }
    };

    // Додаємо метод remove() для кожного типу елементів
    for (var i = 0; i < types.length; i++) {
      var type = types[i];
      if (window[type] && !window[type].prototype.remove) {
        window[type].prototype.remove = removeNode;
      }
    }
  };

  // Виклик функції поліфіла
  removePolyfill();

})();

(function (window) {
  // Конструктор для об'єкту JustValidate
  function JustValidate(selector, options) {
    this.options = options || {};
    this.rules = this.options.rules || {};
    this.messages = this.options.messages || {};
    this.colorWrong = this.options.colorWrong || "#B81111";
    this.$form = null;
    this.elements = [];
    this.result = {};
    this.tooltip = this.options.tooltip || {};
    this.tooltipFadeOutTime = this.tooltip.fadeOutTime || 5000;
    this.tooltipFadeOutClass = this.tooltip.fadeOutClass || "just-validate-tooltip-hide";
    this.tooltipSelectorWrap = document.querySelectorAll(this.tooltip.selectorWrap) || document.querySelectorAll(".just-validate-tooltip-container");
    this.bindHandlerKeyup = this.handlerKeyup.bind(this);
    this.submitHandler = this.options.submitHandler || undefined;
    this.invalidFormCallback = this.options.invalidFormCallback || undefined;
    this.promisesRemote = [];
    this.isValidationSuccess = false;
    this.focusWrongField = this.options.focusWrongField || false;
    this.REGEXP = {
      email: /^(([^<>()[\]\\.,;:\s@"]+(\.[^<>()[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/,
      zip: /^\d{5}(-\d{4})?$/,
      phone: /^([0-9]( |-)?)?(\(?[0-9]{3}\)?|[0-9]{3})( |-)?([0-9]{3}( |-)?[0-9]{4}|[a-zA-Z0-9]{7})$/,
      password: /[^\w\d]*(([0-9]+.*[A-Za-z]+.*)|[A-Za-z]+.*([0-9]+.*))/,
      strengthPass: /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)[a-zA-Z\d]/
    };
    this.DEFAULT_REMOTE_ERROR = "Error";

    // Ініціалізація форми
    this.setForm(document.querySelector(selector));
  }

  JustValidate.prototype = {
    // Основні правила валідації за замовчуванням
    defaultRules: {
      email: { required: true, email: true },
      name: { required: true, minLength: 3, maxLength: 15 },
      text: { required: true, maxLength: 300, minLength: 5 },
      password: { required: true, password: true, minLength: 4, maxLength: 8 },
      zip: { required: true, zip: true },
      phone: { phone: true }
    },

    // Основні повідомлення про помилки за замовчуванням
    defaultMessages: {
      required: "The field is required",
      email: "Please, type a valid email",
      maxLength: "The field must contain a maximum of :value characters",
      minLength: "The field must contain a minimum of :value characters",
      password: "Password is not valid",
      remote: "Email already exists",
      strength: "Password must contain at least one uppercase letter, one lowercase letter, and one number",
      "function": "Function returned false"
    },

    // Обробник події натискання клавіші
    handlerKeyup: function (e) {
      var target = e.target;
      var name = target.getAttribute("data-validate-field");
      var value = target.value;
      delete this.result[name];
      this.validateItem({ name: name, value: value, group: [], isKeyupChange: true });
      this.renderErrors();
    },

    // Додає подію обробника подій до елемента
    setterEventListener: function (element, event, handler, action) {
      if (action === "add") {
        element.addEventListener(event, handler);
      } else if (action === "remove") {
        element.removeEventListener(event, handler);
      }
    },

    // Отримує реальне значення елементів форми
    getElementsRealValue: function () {
      var elements = this.$form.querySelectorAll("*");
      var values = {};
      for (var i = 0; i < elements.length; i++) {
        var element = elements[i];
        var name = element.getAttribute("name");
        if (name) {
          if (element.type === "checkbox") {
            values[name] = element.checked;
          } else {
            values[name] = element.value;
          }
        }
      }
      return values;
    },

    // Основні методи валідації
    validateRequired: function (value) {
      return !this.isEmpty(value);
    },

    validateEmail: function (value) {
      return this.isEmail(value);
    },

    validatePhone: function (value) {
      return this.isPhone(value);
    },

    validateMinLength: function (value, length) {
      return this.checkLengthMin(value, length);
    },

    validateMaxLength: function (value, length) {
      return this.checkLengthMax(value, length);
    },

    validateStrengthPass: function (value) {
      return this.checkStrengthPass(value);
    },

    validatePassword: function (value) {
      return this.isPassword(value);
    },

    validateZip: function (value) {
      return this.isZip(value);
    },

    // Основний метод валідації елементів форми
    validateItem: function (item) {
      var name = item.name;
      var value = item.value;
      var group = item.group || [];
      var isKeyupChange = item.isKeyupChange || false;

      var rules = this.rules[name] || this.defaultRules[name] || false;
      if (rules) {
        for (var rule in rules) {
          var param = rules[rule];
          if (rule !== t && rule !== d && "" == value) {
            continue;
          }
          switch (rule) {
            case d:
              if (typeof param !== "function") {
                break;
              }
              if (param(name, value)) {
                break;
              }
              return void this.generateMessage(d, name, param);

            case t:
              if (!param) {
                break;
              }
              if (group.length) {
                var isValid = false;
                group.forEach(function (element) {
                  if (this.validateRequired(element)) {
                    isValid = true;
                  }
                });
                if (isValid) {
                  break;
                }
              } else if (this.validateRequired(value)) {
                break;
              }
              return void this.generateMessage(t, name);

            case i:
              if (!param) {
                break;
              }
              if (this.validateEmail(value)) {
                break;
              }
              return void this.generateMessage(i, name);

            // Додаткові правила валідації можна додавати тут...

            case l:
              if (!isKeyupChange) {
                break;
              }
              if (!param) {
                break;
              }
              var remoteConfig = {
                name: name,
                value: value,
                url: param.url,
                method: param.method,
                sendParam: param.sendParam
              };
              var field = this.$form.querySelector('input[data-validate-field="' + name + '"]');
              this.setterEventListener(field, "keyup", this.handlerKeyup, "remove");
              void this.promisesRemote.push(this.validateRemote(remoteConfig));
              break;
          }
        }
      }
    },

    // Генерує повідомлення про помилку
    generateMessage: function (type, name, value) {
      var messages = this.messages || this.defaultMessages;
      var message = messages[type] && messages[type][name] || messages[type] || this.defaultMessages[type] || this.DEFAULT_REMOTE_ERROR;
      if (value) {
        message = message.replace(":value", value.toString());
      }
      this.result[name] = { message: message };
    },

    // Очищає повідомлення про помилки
    clearErrors: function () {
      var errorLabels = document.querySelectorAll(".js-validate-error-label");
      for (var i = 0; i < errorLabels.length; i++) {
        errorLabels[i].remove();
      }
      var errorFields = document.querySelectorAll(".js-validate-error-field");
      for (var j = 0; j < errorFields.length; j++) {
        var field = errorFields[j];
        field.classList.remove("js-validate-error-field");
        field.style.border = "";
        field.style.color = "";
      }
    },

    // Рендерить повідомлення про помилки
    renderErrors: function () {
      var _this = this;
      this.clearErrors();
      this.unlockForm();
      this.isValidationSuccess = false;

      if (Object.keys(this.result).length === 0) {
        this.isValidationSuccess = true;
        if (this.submitHandler) {
          var formData = this.getElementsRealValue();
          return void this.submitHandler(this.$form, formData, h);
        }
        this.$form.submit();
      }

      for (var name in this.result) {
        var errorMessage = this.result[name].message;
        var fields = this.$form.querySelectorAll('[data-validate-field="' + name + '"]');
        var lastField = fields[fields.length - 1];
        var errorLabel = document.createElement("div");

        errorLabel.innerHTML = errorMessage;
        errorLabel.className = "js-validate-error-label";
        errorLabel.setAttribute("style", "color: " + this.colorWrong);

        lastField.style.border = "1px solid " + this.colorWrong;
        lastField.style.color = "" + this.colorWrong;
        lastField.classList.add("js-validate-error-field");

        if (lastField.type === "checkbox" || lastField.type === "radio") {
          var label = document.querySelector('label[for="' + lastField.getAttribute("id") + '"]');
          if (label) {
            label.parentNode.insertBefore(errorLabel, label.nextSibling);
          } else {
            lastField.parentNode.insertBefore(errorLabel, lastField.nextSibling);
          }
        } else {
          lastField.parentNode.insertBefore(errorLabel, lastField.nextSibling);
        }
      }

      if (this.tooltipSelectorWrap.length) {
        this.state.tooltipsTimer = setTimeout(function () {
          _this.hideTooltips();
        }, this.tooltipFadeOutTime);
      }
    },

    // Метод валідації віддалених даних
    validateRemote: function (config) {
      var _this2 = this;
      var name = config.name;
      var value = config.value;
      var url = config.url;
      var method = config.method;
      var sendParam = config.sendParam;

      return new Promise(function (resolve) {
        h({
          url: url,
          method: method,
          data: _defineProperty({}, sendParam, value),
          async: true,
          callback: function callback(response) {
            if (response.toLowerCase() === "ok") {
              resolve("ok");
            } else {
              _this2.generateMessage("remote", name);
              resolve({ type: "incorrect", name: name });
            }
          },
          error: function error() {
            _this2.generateMessage("remote", name);
            resolve({ type: "error", name: name });
          }
        });
      });
    },

    // Метод блокування форми
    lockForm: function () {
      var elements = this.$form.querySelectorAll("input, textarea, button, select");
      for (var i = 0; i < elements.length; i++) {
        var element = elements[i];
        element.setAttribute("disabled", "disabled");
        element.style.pointerEvents = "none";
        element.style.webkitFilter = "grayscale(100%)";
        element.style.filter = "grayscale(100%)";
      }
    },

    // Метод розблокування форми
    unlockForm: function () {
      var elements = this.$form.querySelectorAll("input, textarea, button, select");
      for (var i = 0; i < elements.length; i++) {
        var element = elements[i];
        element.removeAttribute("disabled");
        element.style.pointerEvents = "";
        element.style.webkitFilter = "";
        element.style.filter = "";
      }
    },

    // Метод ініціалізації форми
    setForm: function (form) {
      var _this3 = this;
      this.$form = form;
      this.$form.setAttribute("novalidate", "novalidate");
      this.$form.addEventListener("submit", function (e) {
        e.preventDefault();
        _this3.result = [];
        _this3.getElements();
        if (_this3.promisesRemote.length) {
          Promise.all(_this3.promisesRemote).then(function () {
            _this3.promisesRemote = [];
            if (_this3.isValidationSuccess) {
              _this3.validationSuccess();
            } else {
              _this3.validationFailed();
            }
          });
        } else {
          if (_this3.isValidationSuccess) {
            _this3.validationSuccess();
          } else {
            _this3.validationFailed();
          }
        }
      });
    },

    // Метод перевірки, чи є значення порожнім
    isEmpty: function (value) {
      var trimmedValue = value;
      if (value.trim) {
        trimmedValue = value.trim();
      }
      return !trimmedValue;
    },

    // Метод успішної валідації форми
    validationSuccess: function () {
      var _this4 = this;
      if (Object.keys(this.result).length === 0) {
        if (this.submitHandler) {
          var formData = this.getElementsRealValue();
          this.submitHandler(this.$form, formData, h);
          return;
        }
        this.$form.submit();
      }
    },

    // Метод валідації форми не пройшов
    validationFailed: function () {
      if (this.focusWrongField) {
        var fields = this.$form.querySelectorAll(".js-validate-error-field");
        if (fields.length) {
          fields[0].focus();
        }
      }
      if (this.invalidFormCallback) {
        this.invalidFormCallback(this.result);
      }
    },

    // Метод отримання елементів форми
    getElements: function () {
      var elements = this.$form.querySelectorAll("[data-validate-field]");
      for (var i = 0; i < elements.length; i++) {
        var element = elements[i];
        var name = element.getAttribute("data-validate-field");
        if (this.elements.indexOf(name) === -1) {
          this.elements.push(name);
          var inputType = element.getAttribute("type");
          if (inputType !== "submit" && inputType !== "button") {
            if (inputType === "checkbox") {
              element.addEventListener("change", this.bindHandlerKeyup);
            } else {
              element.addEventListener("keyup", this.bindHandlerKeyup);
            }
          }
        }
      }
    },

    // Метод перевірки, чи є значення електронною поштою
    isEmail: function (value) {
      return this.REGEXP.email.test(value);
    },

    // Метод перевірки, чи є значення номером телефону
    isPhone: function (value) {
      return this.REGEXP.phone.test(value);
    },

    // Метод перевірки, чи є значення паролем
    isPassword: function (value) {
      return this.REGEXP.password.test(value);
    },

    // Метод перевірки, чи є значення поштовим індексом
    isZip: function (value) {
      return this.REGEXP.zip.test(value);
    },

    // Метод перевірки мінімальної довжини значення
    checkLengthMin: function (value, length) {
      return value.length >= length;
    },

    // Метод перевірки максимальної довжини значення
    checkLengthMax: function (value, length) {
      return value.length <= length;
    },

    // Метод перевірки сили паролю
    checkStrengthPass: function (value) {
      return this.REGEXP.strengthPass.test(value);
    }
  };

  window.JustValidate = JustValidate;
})(window);
